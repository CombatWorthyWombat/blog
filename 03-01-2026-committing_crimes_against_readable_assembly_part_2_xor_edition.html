<head>
  <meta charset="utf-8">
  <title>CWW.committing crimes against readable assembly part 2, only xor</title>
  <link rel="stylesheet" href="style.css">
</head>

<body>
<div style="display: inline-block; text-align: left;"><pre>
<bl>┏━━┓</bl>
<a href="index.html">BACK</a>
<bl>┗━━┛</bl>
╔══════════════════════════════════════════════════════════════════════════════════╗
║ <bl>Contents - 03-01-2026 committing crimes against readable assembly part 2, xor </bl>   ║
║ <bl>edition</bl>                                                                          ║
║ -------------------------------------------------------------------------------- ║
║ <y>setting some ground-rules</y>                                                        ║
║ <y>xor info-dump</y>                                                                    ║
║ <y>clearing registers</y>                                                               ║
║ <y>loading and moving values around registers</y>                                       ║
║ <y>conditional flow</y>                                                                 ║
║ <y>basic arithmetic</y>                                                                 ║
║ <y>basic logic</y>                                                                      ║
╚══════════════════════════════════════════════════════════════════════════════════╝
╔══════════════════════════════════════════════════════════════════════════════════╗
║                                                                                  ║
║ So, where do we even begin?                                                      ║
║                                                                                  ║
║ If we are to make a complier for regular assembly, that only outputs <pu>xor</pu>         ║
║ instructions (that's the aim here btw) then we better be able to translate a     ║
║ decent chunk of the assembly instruction set into <pu>xor</pu> equivalents                ║
║                                                                                  ║
║ Here is the list of assembly instructions, in order of usage in some popular     ║
║ opensource programs (from <a href="https://www.strchr.com/x86_machine_code_statistics">here</a>):                                                 ║
║                                                                                  ║
║         <pu>mov</pu>                       <f1># 35%</f1>                                          ║
║         <pu>push</pu>                      <f1># 10%</f1>                                          ║
║         <pu>call</pu>                      <f1># 6%</f1>                                           ║
║         <pu>cmp</pu>                       <f1># 5%</f1>                                           ║
║         <pu>add</pu>                       <f1># 4%</f1>                                           ║
║         <pu>pop</pu>                       <f1># 4%</f1>                                           ║
║         <pu>lea</pu>                       <f1># 4%</f1>                                           ║
║         <pu>test</pu>                      <f1># 3%</f1>                                           ║
║         <pu>je</pu>                        <f1># 3%</f1>                                           ║
║         <pu><pu>xor</pu></pu>                       <f1># 2%</f1>                                           ║
║         <pu>jmp</pu>                       <f1># 2%</f1>                                           ║
║         <pu>jne</pu>                       <f1># 2%</f1>                                           ║
║         <pu>ret</pu>                       <f1># 1%</f1>                                           ║
║         <pu>inc</pu>                       <f1># 1%</f1>                                           ║
║         <pu>sub</pu>                       <f1># 1%</f1>                                           ║
║         <pu>fld</pu>                       <f1># 1%</f1>                                           ║
║         <pu>and</pu>                       <f1># 1%</f1>                                           ║
║         <pu>fstp</pu>                      <f1># 1%</f1>                                           ║
║         <pu>shl</pu>                       <f1># 1%</f1>                                           ║
║         <pu>or</pu>                        <f1># 1%</f1>                                           ║
║         <f>others</f>                    <f1># 11%</f1>                                          ║
║                                                                                  ║
║ As a realistic aim, lets rule out some assembly instructions that I think might  ║
║ be either pretty tricky, or just require abstraction after we handle the more    ║
║ fundamental items:                                                               ║
║                                                                                  ║
║ <f1>-></f1> Floating point stuff (<pu>fld</pu>, <pu>fstp</pu>) <f1>I don't even know how these work tbh...</f1>      ║
║ <f1>-></f1> Anything that alters rip (<pu>ret</pu>, <pu>call</pu>, <pu>jmp</pu>, <pu>syscall</pu>, <pu>0x80</pu>)                      ║
║ <f1>-></f1> Stack addressing (<pu>push</pu>, <pu>pop</pu>) <f1>maybe later?</f1>                                     ║
║                                                                                  ║
║ This does mean we can't just pipe the output of your favourite complier into     ║
║ our <pu>xor</pu> program. So we'd potentially be limited to my handwritten assembly       ║
║                                                                                  ║
╠══════════════════════════════════════════════════════════════════════════════════╣
║                                                                                  ║
║ I do have to remind myself of the full range of options available to us from     ║
║ the <pu>xor</pu> instruction - if you are familiar with this please feel free to skip     ║
║ this section.                                                                    ║
║                                                                                  ║
║ The truth table for <pu>xor</pu> is as follows:                                           ║
║                                                                                  ║
║  <bl>A  <pu>xor</pu>  B  <f1>=</f1>   C</bl>                                                                ║
║  <bl>1       1  <f1>-></f1>  0</bl>                                                                ║
║  <bl>1       0  <f1>-></f1>  1</bl>                                                                ║
║  <bl>0       1  <f1>-></f1>  1</bl>                                                                ║
║  <bl>0       0  <f1>-></f1>  0</bl>                                                                ║
║                                                                                  ║
║ <pu>xor</pu> also has the following useful properties:                                    ║
║                                                                                  ║
║ <bl>x <pu>xor</pu> a <f>=</f> a <pu>xor</pu> x <f1>(order of operations doesn’t matter)</f1></bl>                           ║
║ <bl>a <pu>xor</pu> a <f>=</f> 0</bl>                                                                      ║
║ <bl>a <pu>xor</pu> x <pu>xor</pu> a <f>=</f> x <f1>(commutative - xoring by the same value twice cancels out)</f1></bl>     ║
║ <bl>x <pu>xor</pu> 0 <f>=</f> x</bl>                                                                      ║
║ <bl>a <pu>xor</pu> (b <pu>xor</pu> c) <f>=</f> (a <pu>xor</pu> b) <pu>xor</pu> c <f1>(associative)</f1></bl>                                  ║
║                                                                                  ║
║ <a href="https://www.felixcloutier.com/x86/xor">Here</a> is the blurb from the x86_64 intel instruction manual for <pu>xor</pu>:              ║
║                                                                                  ║
╠══------------------------------------------------------------------------------══╣
║ <f>Performs a bitwise exclusive OR (xor) operation on the destination (first) and</f>   ║
║ <f>source (second) operands and stores the result in the destination operand</f>        ║
║ <f>location. The source operand can be an immediate, a register, or a memory</f>        ║
║ <f>location; the destination operand can be a register or a memory location.</f>        ║
║ <f>(However, two memory operands cannot be used in one instruction.) Each bit of</f>    ║
║ <f>the result is 1 if the corresponding bits of the operands are different; each</f>    ║
║ <f>bit is 0 if the corresponding bits are the same. This instruction can be used</f>    ║
║ <f>with a LOCK prefix to allow the instruction to be executed atomically.</f>           ║
╠══------------------------------------------------------------------------------══╣
║                                                                                  ║
║ So that allows us to play with not only direct values, but registers and         ║
║ intermediate values (<bl>-128 <f1>-></f1> 127</bl> as well)                                        ║
║                                                                                  ║
╠══════════════════════════════════════════════════════════════════════════════════╣
║                                                                                  ║
║ If we can work out the following sorts of instructions we ought to be well on    ║
║ our way:                                                                         ║
║                                                                                  ║
║ <f1>-></f1> 1 clearing a register                                                         ║
║ <f1>-></f1> 2 loading and moving values around registers                                  ║
║ <f1>-></f1> 3 conditional flow                                                            ║
║ <f1>-></f1> 4 basic arithmetic                                                            ║
║ <f1>-></f1> 5 basic logic                                                                 ║
║                                                                                  ║
╠══-----==<o>[ 1 ]</o>==----------------------------------------------------------------══╣
║                                                                                  ║	
║ Our first objective is pretty easy, if a number <bl>x</bl> is <pu>xor</pu>ed with itself, it       ║
║ always yields <bl>0</bl>                                                                  ║
║                                                                                  ║
║ So a "clear" instruction like:                                                   ║
║                                                                                  ║
║       <f><pu>mov</pu> <g>rax</g>, <bl>0x00</bl></f>                                                              ║
║                                                                                  ║
║ Becomes:                                                                         ║
║                                                                                  ║
║       <f><pu>xor</pu> <g>rax</g>, <g>rax</g></f>                                                               ║
║                                                                                  ║
╠══-----==<o>[ 2 ]</o>==----------------------------------------------------------------══╣
║                                                                                  ║
║ Loading values into registers is where we have our first couple of decisions to  ║
║ make                                                                             ║
║                                                                                  ║
║ Firstly, do we want all relevant program information be handled internally by    ║
║ the <pu>xor</pu> instructions?                                                            ║
║                                                                                  ║
║ And secondly (when done externally), how pure do we want to get with "only"      ║
║ using <pu>xor</pu>?                                                                       ║
║                                                                                  ║
║ Say the answer to the first question is <f>"yes - all logic should be handled in    ║
║ code as xor"</f>, then loading <bl>64</bl> into <g>rax</g> could look like:                          ║
║                                                                                  ║
║       <f><pu>xor</pu> <g>rax</g>, <g>rax</g></f>                                                               ║
║       <f><pu>xor</pu> <g>rax</g>, <bl>0x40</bl></f>                                                              ║
║                                                                                  ║
║ The issue with this is twofold, though it's nothing to do with it not being <pu>xor</pu>  ║
║                                                                                  ║
║ Firstly - this way of loading values into registers is more efficient that a <pu>mov</pu> ║
║ instruction, consequently then, this is a common way to see values loaded due to ║
║ compiler optimisation. Decompilers and seasoned reverse engineers alike can      ║
║ recognise this pretty easily, and we can't have that                             ║
║                                                                                  ║
║ It's also revealing with regard to our hardcoded values. If our "<bl>64</bl>" had some    ║
║ inherent association (say it was a prime number used in crypto, or the address   ║
║ of a C2 server) then simply seeing that value can sometimes be enough to infer   ║
║ intent about a binary                                                            ║
║                                                                                  ║
║ This leads us to the intuitive solution to handle the hardcoded values outside   ║
║ our code (in our compiler) where we could choose a random number <bl>n</bl>, such that    ║
║ <bl>64</bl> <pu>xor</pu> <bl>n</bl> = <bl>a</bl>:                                                                    ║
║                                                                                  ║
╠══------------------------------------------------------------------------------══╣
║       <f1><pu>xor</pu> <g>rax</g>, <g>rax</g></f1>                <f1># clear</f1>                                        ║
║       <f1><pu>xor</pu> <g>rax</g>, <bl>a</bl></f1>                  <f1># rax = [64||n]</f1>                                ║
║       <f1><pu>xor</pu> <g>rax</g>, <bl>n</bl></f1>                  <f1># rax = [64||n||n] = 64</f1>                        ║
╠══------------------------------------------------------------------------------══╣
║                                                                                  ║
║ This hides our <bl>64</bl> value, as it is <pu>xor</pu>-ed outside our logic.                      ║
║                                                                                  ║
║ We could even designate a register as a "scratch register" - load a somewhat     ║
║ random value into it - and use that as our "<bl>n</bl>" value. so loading two values, <bl>64</bl>  ║
║ and <bl>100</bl> into memory could look like (<g>sch</g> = our scratch registers):               ║
║                                                                                  ║
╠══------------------------------------------------------------------------------══╣
║ <y>INIT:</y>                                                                            ║
║       <f><pu>xor</pu> <g>sch</g>, <g>sch</g></f>                <f1># clear</f1>                                        ║
║       <f><pu>xor</pu> <g>sch</g>, <bl>n</bl></f>                  <f1># load our "random" number into scratch</f1>        ║
║                                                                                  ║
║ <y>RETRIEVING HARDCODED VALUES:</y>                                                     ║
║       <f><pu>xor</pu> <g>rax</g>, <g>rax</g></f>                <f1># clear</f1>                                        ║
║       <f><pu>xor</pu> <g>rax</g>, [<g>sch</g>||<bl>64</bl>]</f>          <f1># bracketed piece is calculated externally</f1>     ║
║       <f><pu>xor</pu> <g>rax</g>, <g>sch</g></f>                <f1># rax = [64||n||n] = 64</f1>                        ║
║                                                                                  ║
║       <f><pu>xor</pu> <g>sch</g>, <g>rax</g></f>                <f1># scratch: [n||64]</f1>                             ║
║                                                                                  ║
║       <f><pu>xor</pu> <g>rbx</g>, <g>rbx</g></f>                <f1># clear</f1>                                        ║
║       <f><pu>xor</pu> <g>rbx</g>, [<g>sch</g>||<bl>100</bl>]</f>         <f1># bracketed piece is calculated externally</f1>     ║
║       <f><pu>xor</pu> <g>rbx</g>, <g>sch</g></f>                <f1># rbx now contains 100</f1>                         ║
║                                                                                  ║
║       <f><pu>xor</pu> <g>sch</g>, <g>rbx</g></f>                <f1># scratch: [n||64||100]</f1>                        ║
╠══------------------------------------------------------------------------------══╣
║                                                                                  ║
║ I am kind of sad about this as a solution, as it ruins some of the "purity" of   ║
║ genuinely trying to do everything using <pu>xor</pu>, given that we are relying on doing  ║
║ some non-<pu>xor</pu> calculations externally in our compiler (especially random numbers) ║
║                                                                                  ║
║ Perhaps we could do this the other way round, where our scratch register         ║
║ is an <pu>xor</pu>ed list of all of our constants, (say <bl>64</bl>, <bl>100</bl>, <bl>80</bl>) and we retrieve the  ║
║ value we want by <pu>xor</pu>ing the list with all the constants we don’t want:           ║
║                                                                                  ║
╠══------------------------------------------------------------------------------══╣
║ <y>INIT:</y>                                                                            ║
║       <f><pu>xor</pu> <g>sch</g>, <g>sch</g></f>                                                               ║
║       <f><pu>xor</pu> <g>sch</g>, [<bl>64</bl>||<bl>100</bl>||<bl>80</bl>]</f>      <f1># calculated externally, as before</f1>             ║
║                                                                                  ║
║ <y>RETRIEVING HARDCODED VALUES:</y>                                                     ║
║       <f><pu>xor</pu> <g>rax</g>, <g>rax</g></f>                                                               ║
║       <f><pu>xor</pu> <g>rax</g>, <g>sch</g></f>                                                               ║
║       <f><pu>xor</pu> <g>rax</g>, [<bl>100</bl>||<bl>80</bl>]</f>          <f1># rax now contains 64</f1>                          ║
║                                                                                  ║
║       <f><pu>xor</pu> <g>rbx</g>, <g>rbx</g></f>                                                               ║
║       <f><pu>xor</pu> <g>rbx</g>, <g>sch</g></f>                                                               ║
║       <f><pu>xor</pu> <g>rbx</g>, [<bl>64</bl>||<bl>80</bl>]</f>           <f1># rcx now contains 100</f1>                         ║
║                                                                                  ║
║       <f><pu>xor</pu> <g>rcx</g>, <g>rcx</g></f>                                                               ║
║       <f><pu>xor</pu> <g>rcx</g>, <g>sch</g></f>                                                               ║
║       <f><pu>xor</pu> <g>rcx</g>, [<bl>100</bl>||<bl>64</bl>]</f>          <f1># rcx now contains 80</f1>                          ║
╠══------------------------------------------------------------------------------══╣
║                                                                                  ║
║ For the sake of obfuscation, I can live with this - at least the computational   ║
║ work being done by our compiler is just <pu>xor</pu>.                                     ║
║                                                                                  ║
╠══-----==<o>[ 3 ]</o>==----------------------------------------------------------------══╣
║                                                                                  ║
║ Here we run into our first (and pretty thorny issue), how do we manage a         ║
║ conditional statement?                                                           ║
║                                                                                  ║
║ Lets clarify here, I don't just mean any conditional - I mean a general purpose  ║
║ conditional. Of course, <pu>xor</pu> is "conditional" in its own way:                     ║
║                                                                                  ║
║ For values of (<bl>a</bl> and <bl>b</bl>) between (<bl>0</bl> <f1>-></f1> <bl>1</bl>):                                        ║
║                                                                                  ║
║       <f><bl>a</bl> <pu>xor</pu> <bl>b</bl> = <bl>1</bl> or <bl>0</bl></f>                                                           ║
║                                                                                  ║
║ There are "conditions" (<bl>a</bl> and <bl>b</bl> values) of <bl>a</bl> <pu>xor</pu> <bl>b</bl> that yield <bl>1</bl>, and conditions  ║
║ that yield <bl>0</bl>. Our issue is that there are multiple conditions that satisfy this  ║
║                                                                                  ║
║ We want just one                                                                 ║
║                                                                                  ║
║ Lets try making a "detect if two registers are equal" function                   ║
║                                                                                  ║
╠══------------------------------------------------------------------------------══╣
║       <f1># let rax be the first register we want to compare</f1>                         ║
║                                                                                  ║
║       <f1># let rcx be the second register we want to compare</f1>                        ║
║                                                                                  ║
║       <f1># let <g>inv</g> be a register filled with 1s (invert register)</f1>                   ║
║                                                                                  ║
║       <f><pu>xor</pu> <g>sc1</g>, <g>sc1</g></f>                                                               ║
║       <f><pu>xor</pu> <g>sc1</g>, <g>rax</g></f>            <f1># copy rax into sc1</f1>                                ║
║                                                                                  ║
║       <f><pu>xor</pu> <g>sc2</g>, <g>sc2</g></f>                                                               ║
║       <f><pu>xor</pu> <g>sc2</g>, <g>rcx</g></f>            <f1># copy rcx into sc2</f1>                                ║
║                                                                                  ║
║       <f><pu>xor</pu> <g>rcx</g>, <g>inv</g></f>            <f1># inverts the bits of rcx</f1>                          ║
║                                                                                  ║
║       <f><pu>xor</pu> <g>rax</g>, <g>rcx</g></f>            <f1># xors the inverted rcx with rax</f1>                   ║
╠══------------------------------------------------------------------------------══╣
║                                                                                  ║
║ This would yield all <bl>1</bl>s in <g>rax</g>, if <g>rax</g> and <g>rcx</g> were equal - and something else   ║
║ if not. unfortunately this still isn't great, as the "failure" condition isn't   ║
║ reliable (any combination of <bl>1</bl>s and at least one <bl>0</bl>)                              ║
║                                                                                  ║
║ Turns out we can do some trickery with addressing, as if two registers contain   ║
║ the same value then operating on the values contained at those addresses can     ║
║ act as a test for whether they are the same or not:                              ║
║                                                                                  ║
╠══------------------------------------------------------------------------------══╣
║       <f1># we have registers rdx and rcx (which contain some values)</f1>                ║
║                                                                                  ║
║       <f><pu>xor</pu> [<g>rdx</g>], <bl>0x00</bl></f>         <f1># memory at rdx now contains 0</f1>                     ║
║                                                                                  ║
║       <f><pu>xor</pu> [<g>rcx</g>], <bl>0x01</bl></f>         <f1># memory at rcx now contains 1</f1>                     ║
║                                                                                  ║
║       <f><pu>xor</pu> <g>rax</g>, <g>rax</g></f>                                                               ║
║       <f><pu>xor</pu> <g>rax</g>, [<g>rdx</g>]</f>          <f1># move the memory at our first write into rax</f1>      ║
╠══------------------------------------------------------------------------------══╣
║                                                                                  ║
║ The trick here is that if <g>rdx</g> and <g>rcx</g> are the same - then the 0 was overwritten  ║
║ by a 1, and if not - it remained a 0. This stores the value 1 in <g>rax</g> if both of  ║
║ our registers were the same, and 0 if they were different                        ║
║                                                                                  ║
║ Amusingly, I started to do a bunch of other stuff that relied on the above being ║
║ correct, without actually going back and checking my homework - so that'll teach ║
║ me... Thankfully the principle still holds, and conditionals are possible        ║
║                                                                                  ║
║ Lets fix it now, the problem is that when we:                                    ║
║                                                                                  ║
║       <f><pu>xor</pu> [<g>rdx</g>], <bl>0x00</bl></f>                                                            ║
║                                                                                  ║
║ This actually does nothing, as <bl>a</bl> <pu>xor</pu> <bl>0</bl> = <bl>a</bl>. Okay, eaxy fix then - just <f><pu>xor</pu> [<g>rdx</g>]</f> ║
║ with itself to make sure the memory address located at the value pointed to by   ║
║ <g>rdx</g> is <bl>0</bl>. However, the intel manual has something to say about this:             ║
║                                                                                  ║
║ <f>"Two memory operands cannot be used in one instruction"</f>                          ║
║                                                                                  ║
║ So we can't do the intuitive:                                                    ║
║                                                                                  ║
║       <f><pu>xor</pu> [<g>rdx</g>], [<g>rdx</g>]</f>                                                           ║
║                                                                                  ║
║ Instead we have to "realise" <f>[<g>rdx</g>]</f>  to a scratch register, and then do it from   ║
║ there:                                                                           ║
║                                                                                  ║
╠══------------------------------------------------------------------------------══╣
║       <f><pu>xor</pu> <g>sch</g>, <g>sch</g></f>                                                               ║
║       <f><pu>xor</pu> <g>sch</g>, [<g>rdx</g>]</f>          <f1># loads the memory at address rdx into sch</f1>         ║
║                                                                                  ║
║       <f><pu>xor</pu> [<g>rdx</g>], <g>sch</g></f>          <f1># zeros out the memory at rdx</f1>                      ║
╠══------------------------------------------------------------------------------══╣
║                                                                                  ║
║ Which gives us the actually functional comparison for if two values are equal,   ║
║ where <g>rax</g> == <bl>1</bl> if <g>rdx</g> and <g>rcx</g> are equal, and <g>rax</g> == <bl>0</bl> if they are not:           ║
║                                                                                  ║
╠══------------------------------------------------------------------------------══╣
║       <f1># we have registers rdx and rcx (which contain some values)</f1>                ║
║                                                                                  ║
║       <f><pu>xor</pu> <g>sch</g>, <g>sch</g></f>                                                               ║
║       <f><pu>xor</pu> <g>sch</g>, [<g>rdx</g>]</f>                                                             ║
║       <f><pu>xor</pu> [<g>rdx</g>], <g>sch</g></f>          <f1># memory at rdx now contains 0</f1>                     ║
║                                                                                  ║
║       <f><pu>xor</pu> <g>sch</g>, <g>sch</g></f>                                                               ║
║       <f><pu>xor</pu> <g>sch</g>, [<g>rcx</g>]</f>                                                             ║
║       <f><pu>xor</pu> [<g>rcx</g>], <g>sch</g></f>          <f1># memory at rcx now contains 0</f1>                     ║
║       <f><pu>xor</pu> [<g>rcx</g>], <bl>0x1</bl></f>          <f1># memory at rcx now contains 1</f1>                     ║
║                                                                                  ║
║       <f><pu>xor</pu> <g>rax</g>, <g>rax</g></f>                                                               ║
║       <f><pu>xor</pu> <g>rax</g>, [<g>rdx</g>]</f>          <f1># move the memory at our first write into rax</f1>      ║
╠══------------------------------------------------------------------------------══╣
║                                                                                  ║
║ We can rephrase this for comparison to any "<bl>n</bl>" aswell:                           ║
║                                                                                  ║
╠══------------------------------------------------------------------------------══╣
║       <f><pu>xor</pu> <g>sch</g>, <g>sch</g></f>                                                               ║
║       <f><pu>xor</pu> <g>sch</g>, [<g>rbx</g>]</f>                                                             ║
║       <f><pu>xor</pu> [<g>rbx</g>], <g>sch</g></f>                                                             ║
║       <f><pu>xor</pu> [<g>rbx</g>], <bl>0x00</bl></f>          <f1># memory at rbx now contains 0</f1>                    ║
║                                                                                  ║
║       <f><pu>xor</pu> <g>sch</g>, <g>sch</g></f>                                                               ║
║       <f><pu>xor</pu> <g>sch</g>, [<bl>n</bl>]</f>                                                               ║
║       <f><pu>xor</pu> [<bl>n</bl>], <g>sch</g></f>                                                               ║
║       <f><pu>xor</pu> [<bl>n</bl>], <bl>0x01</bl></f>            <f1># memory at n now contains 1</f1>                      ║
║                                                                                  ║
║       <f><pu>xor</pu> <g>rax</g>, <g>rax</g></f>                                                               ║
║       <f><pu>xor</pu> <g>rax</g>, [<g>rbx</g>]</f>           <f1># if rbx == n, rax == 1 else 0</f1>                    ║
╠══------------------------------------------------------------------------------══╣
║                                                                                  ║
║ Here we are checking the memory at the address pointed to by <f>[<bl>n</bl>]</f> which I imagine ║
║ would often crash my program (especially for <bl>n</bl> == <bl>0</bl> checks) - that’s a problem   ║
║ for future <r>CWW</r> to work out :)                                                    ║
║                                                                                  ║
║ Theoretically though, this works as a comparison statement, but how do we "do"   ║
║ something based on <g>rax</g> == <bl>1</bl> or <bl>0</bl>?                                                ║
║                                                                                  ║
║ We can place our values to "choose" from into two spots in memory (<bl>a</bl> and <bl>b</bl>) we   ║
║ then can use our <bl>1</bl> or <bl>0</bl> value to select between them:                            ║
║                                                                                  ║
╠══------------------------------------------------------------------------------══╣
║ <y>VALUE A:</y>                                                                         ║
║       <f><pu>xor</pu> <g>rcx</g>, <g>rcx</g></f>                                                               ║
║       <f><pu>xor</pu> <g>rcx</g>, <bl>a</bl></f>                                                                 ║
║                                                                                  ║
║ <y>VALUE B:</y>                                                                         ║
║       <f><pu>xor</pu> <g>rdx</g>, <g>rdx</g></f>                                                               ║
║       <f><pu>xor</pu> <g>rdx</g>, <bl>b</bl></f>                                                                 ║
║                                                                                  ║
║ <y>COMPARISON OF RBX TO N:</y>                                                          ║
║       <f><pu>xor</pu> <g>sch</g>, <g>sch</g></f>                                                               ║
║       <f><pu>xor</pu> <g>sch</g>, [<g>rbx</g>]</f>                                                             ║
║       <f><pu>xor</pu> [<g>rbx</g>], <g>sch</g></f>                                                             ║
║       <f><pu>xor</pu> [<g>rbx</g>], <bl>0x00</bl></f>         <f1># memory at rbx now contains 0</f1>                     ║
║                                                                                  ║
║       <f><pu>xor</pu> <g>sch</g>, <g>sch</g></f>                                                               ║
║       <f><pu>xor</pu> <g>sch</g>, [<bl>n</bl>]</f>                                                               ║
║       <f><pu>xor</pu> [<bl>n</bl>], <g>sch</g></f>                                                               ║
║       <f><pu>xor</pu> [<bl>n</bl>], <bl>0x01</bl></f>           <f1># memory at n now contains 1</f1>                       ║
║                                                                                  ║
║       <f><pu>xor</pu> <g>rax</g>, <g>rax</g></f>                                                               ║
║       <f><pu>xor</pu> <g>rax</g>, [<g>rbx</g>]</f>          <f1># if rbx == n, rax == 1 else 0</f1>                     ║
║                                                                                  ║
║ <y>LOOKUP INDEXED FROM X ONWARDS:</y>                                                   ║
║       <f><pu>xor</pu> <g>sch</g>, <g>sch</g></f>                                                               ║
║       <f><pu>xor</pu> <g>sch</g>, [<bl>X</bl>]</f>                                                               ║
║       <f><pu>xor</pu> [<bl>X</bl>], <g>sch</g></f>            <f1># memory at X now contains 0</f1>                       ║
║                                                                                  ║
║       <f><pu>xor</pu> <g>sch</g>, <g>sch</g></f>                                                               ║
║       <f><pu>xor</pu> <g>sch</g>, [<bl>X</bl>+<bl>1</bl>]</f>                                                             ║
║       <f><pu>xor</pu> [<bl>X</bl>+<bl>1</bl>], <g>sch</g></f>          <f1># memory at X+1 now contains 0</f1>                     ║
║                                                                                  ║
║       <f><pu>xor</pu> [<bl>X</bl>], <bl>a</bl></f>              <f1># memory at X now contains a</f1>                       ║
║                                                                                  ║
║       <f><pu>xor</pu> [<bl>X</bl>+<bl>1</bl>], <bl>b</bl></f>            <f1># memory at X+1 now contains b</f1>                     ║
║                                                                                  ║
║       <f><r>add</r> <bl>X</bl>, <g>rax</g></f>              <f1># ummmm is that an add instruction...</f1>              ║
║                                                                                  ║
║       <f><pu>xor</pu> <g>rax</g>, <g>rax</g></f>                                                               ║
║       <f><pu>xor</pu> <g>rax</g>, [<bl>X</bl>]</f>            <f1># rax contains a or b</f1>                              ║
╠══------------------------------------------------------------------------------══╣
║                                                                                  ║
╠══-----==<o>[ 4 ]</o>==----------------------------------------------------------------══╣
║                                                                                  ║
║ Can you see it too? there is a single <r>add</r> instruction in our comparison block    ║
║ which kinda ruins the whole <pu>xor</pu> only thing...                                    ║
║                                                                                  ║
║ This is a thorny issue it seems, cause we are trying to make conditionals - but  ║
║ we (here I mean just me) can't without a single add instruction, but most ways   ║
║ of adding require conditionals, or other logic operations :(                     ║
║                                                                                  ║
║ Lets take a look at the logic for addition of single binary digits:              ║
║                                                                                  ║
║ <f>number <bl>1</bl>   number <bl>2</bl>   output</f>                                                     ║
║   <bl>01         01   <f1>-></f1>    10</bl>                                                       ║
║   <bl>00         01   <f1>-></f1>    01</bl>                                                       ║
║   <bl>01         00   <f1>-></f1>    01</bl>                                                       ║
║   <bl>00         00   <f1>-></f1>    00</bl>                                                       ║
║                                                                                  ║
║ Hey, that’s familiar - the second column is just the <pu>xor</pu> truth table from before.║
║ We can't just replace addition with <pu>xor</pu> though, as when the <bl>0</bl>ths places both are ║
║ <bl>1</bl>s, then the  <bl>1</bl>ths place becomes a  <bl>1</bl>. <pu>xor</pu> is addition <o>mod<f>(<bl>2</bl>)</f></o> - or addition of   ║
║ <o>GF<f>(<bl>2</bl>)</f></o>                                                                            ║
║                                                                                  ║
║ In a binary adder circuit this is done through a combination of <pu>and</pu>/<pu>or</pu> logic     ║
║ gates (<a href="https://www.youtube.com/watch?v=QZwneRb-zqA&list=PLFt_AvWsXl0dPhqVsKt1Ni_46ARyiCGSq">this</a> video on computing from first logic principles is great). So can we  ║
║ create <pu>and</pu>/<pu>or</pu> logic operations using just <pu>xor</pu>?                                   ║
║                                                                                  ║
╠══-----==<o>[ 5 ]</o>==----------------------------------------------------------------══╣
║                                                                                  ║
║ We can make a <pu>not</pu> logical operation by reusing our inversion trick from the      ║
║ first failed comparison example. This will probably be useful in future          ║
║ operations so we will assign a register to this value (<g>inv</g> = invert register):   ║
║                                                                                  ║
║       <f><pu>xor</pu> <g>inv</g>, <g>inv</g></f>                                                               ║
║       <f><pu>xor</pu> <g>inv</g>, <bl>0xffffffffffffffff</bl></f>                                                ║
║                                                                                  ║
║ After many days of trying to work out what on earth I'm doing in boolean algebra ║
║ it turns out (I think?) that a combination of <pu>xor</pu>/<pu>not</pu> cannot produce or/and      ║
║ :(                                                                               ║
║                                                                                  ║
║ The hope was that as <pu>xor</pu> has two alternative forms:                              ║
║                                                                                  ║
║ <f1>-></f1> disjunctive <f1>-></f1> <f>(<bl>a</bl> & ¬<bl>b</bl>) | (¬<bl>a</bl> & <bl>b</bl>)</f>                                            ║
║ <f1>-></f1> conjunctive <f1>-></f1> <f>(<bl>a</bl> | <bl>b</bl>) & (¬<bl>a</bl> | ¬<bl>b</bl>)</f>                                            ║
║                                                                                  ║
║ And that we can swap or/and operations (DeMorgan strikes again):                 ║
║                                                                                  ║
║ <f1>-></f1> <f>¬(<bl>a</bl> & <bl>b</bl>) = ¬<bl>a</bl>|¬<bl>b</bl></f>                                                              ║
║ <f1>-></f1> <f>¬(<bl>a</bl> & <bl>b</bl>) = ¬<bl>a</bl> | ¬<bl>b</bl></f>                                                            ║
║                                                                                  ║
║ There might be some sort of equation manipulation we could do to get (<bl>a</bl> & <bl>b</bl>) on  ║
║ one side, and just <pu>xor</pu>/<pu>not</pu> on the other, but it doesn't seem possible.           ║
║                                                                                  ║
║ My tentative reason for this assumption is that every combination of <pu>xor</pu>/<pu>not</pu> can ║
║ be expressed as the following (as repeated <pu>xor</pu> cancels):                         ║
║                                                                                  ║
║       <f1>for some constants:</f1> <f><bl>x</bl>, <bl>y</bl>, <bl>z</bl> <bl>e</bl>{<bl>0</bl>,<bl>1</bl>}:</f>                                        ║
║       <f>f(<bl>a</bl>, <bl>b</bl>) = <bl>x</bl> || (<bl>y</bl> & <bl>a</bl>) || (<bl>z</bl> & <bl>b</bl>)</f>                                          ║
║                                                                                  ║
║ So we have three constants, that can be either <bl>1</bl> or <bl>0</bl> for <f><bl>f</bl>(<bl>a</bl>, <bl>b</bl>)</f>:               ║
║                                                                                  ║
║ <f><bl>xyz</bl>     <bl>f</bl>(<bl>0</bl>,<bl>0</bl>)     <bl>f</bl>(<bl>0</bl>,<bl>1</bl>)     <bl>f</bl>(<bl>1</bl>,<bl>0</bl>)     <bl>f</bl>(<bl>1</bl>,<bl>1</bl>)     reduces to...</f>                ║
║                                                                                  ║
║ <bl>000     0          0          0          0          <f1>constant</f1> 0</bl>                   ║
║ <bl>100     1          1          1          1          <f1>constant</f1> 1</bl>                   ║
║ <bl>010     0          0          1          1          a</bl>                            ║
║ <bl>001     0          1          0          1          b</bl>                            ║
║ <bl>110     1          1          0          0          <f1>not a</bl>                        ║
║ <bl>011     0          1          1          0          a <f1>||</f1> b</bl>                       ║
║ <bl>101     1          0          1          0          <f1>not</f1> b</bl>                        ║
║ <bl>111     1          0          0          1          <f1>not</f1> <f1>(</f1>a <f1>||</f1> b<f1>)</f1></bl>                 ║
║                                                                                  ║
║ There is no way to detect two <bl>1</bl>s - so we can't make an <pu>and</pu>/<pu>or</pu> operation (even    ║
║ though <pu>xor</pu> "contains" them through their alternative forms. Big sad.             ║
║                                                                                  ║
║ Despite currently being stuck, I'm pretty happy with the direction this is going ║
║  - we are starting to generate some pretty unpleasant looking assembly code,     ║
║ though I worry I've bitten off a little more than one meagre student can handle. ║
║ Time will tell                                                                   ║
║                                                                                  ║
║ <r>CWW out</r>                                                                          ║
║                                                                                  ║
║ <f1>PS. I now know about the M/o/Vfuscator, but I'd prefer to see how far I can go</f1>   ║
║ <f1>myself before seeing how they implemented solutions to the problems I'm</f1>          ║
║ <f1>encountering.</f1>                                                                    ║
╚══════════════════════════════════════════════════════════════════════════════════╝
<bl>┏━━┓</bl>
<a href="index.html">BACK</a>
<bl>┗━━┛</bl>
</pre>
